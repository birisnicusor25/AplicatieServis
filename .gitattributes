import random
import time

# 1. CONFIGURAREA PROBLEMEI (Date de intrare)

SKILL_NAMES = ["Revizii", "Electronica", "Motor", "Caroserie"]

def get_date_manuale():
    mecanici_noi = []
    tasks_noi = []

    # Skill-uri: 0=Revizii, 1=Electronica, 2=Motor, 3=Caroserie
    # NIVEL: 1=Incepator, 2=Mediu, 3=Expert
    mecanici_noi = [
        # --- EXPERTI (Scumpi) ---
        {"id": 0, "nume": "Nea Ion (Sef)",   "skill": [0, 1, 2, 3], "nivel": 3, "cost": 150, "max_ore": 8},
        {"id": 1, "nume": "Ing. Costel",     "skill": [1, 2],       "nivel": 3, "cost": 120, "max_ore": 8},

        # --- SPECIALISTI (Medii) ---
        {"id": 2, "nume": "Gigi Motor",      "skill": [0, 2],       "nivel": 2, "cost": 80,  "max_ore": 8},
        {"id": 3, "nume": "Alina Elec",      "skill": [1],          "nivel": 3, "cost": 90,  "max_ore": 8},
        {"id": 4, "nume": "Radu Tinich",     "skill": [3],          "nivel": 2, "cost": 70,  "max_ore": 8},
        {"id": 5, "nume": "Vlad Univ",       "skill": [0, 2, 3],    "nivel": 2, "cost": 75,  "max_ore": 8},

        # --- INCEPATORI / JUNIORI (Ieftini) ---
        {"id": 6, "nume": "Dorel",           "skill": [0, 2],       "nivel": 1, "cost": 40,  "max_ore": 8},
        {"id": 7, "nume": "Marius App",      "skill": [3],          "nivel": 1, "cost": 35,  "max_ore": 8},
        {"id": 8, "nume": "Elena Jr",        "skill": [1],          "nivel": 2, "cost": 50,  "max_ore": 8},
        {"id": 9, "nume": "Petre Ulei",      "skill": [0],          "nivel": 1, "cost": 30,  "max_ore": 8},
    ]

    # GRAD DIFICULTATE: 1=Usor, 2=Mediu, 3=Greu
    raw_tasks = [
        # --- MOTOARE & MECANICA ---
        {"nume": "Audi - Distributie",    "skill_req": 2, "grad_dificultate": 3, "ore": 7},  # Task MARE (Split)
        {"nume": "Mercedes - Cutie",      "skill_req": 2, "grad_dificultate": 3, "ore": 8},  # Task MARE (Split)
        {"nume": "Golf - Schimb Ulei",    "skill_req": 0, "grad_dificultate": 1, "ore": 1},
        {"nume": "Renault - Injectoare",  "skill_req": 2, "grad_dificultate": 2, "ore": 3},

        # --- ELECTRONICA ---
        {"nume": "BMW - ECU Defect",      "skill_req": 1, "grad_dificultate": 3, "ore": 4},
        {"nume": "Tesla - Senzori",       "skill_req": 1, "grad_dificultate": 2, "ore": 2},
        {"nume": "Opel - Alternator",     "skill_req": 1, "grad_dificultate": 2, "ore": 3},
        {"nume": "Dacia - Reset Soft",    "skill_req": 1, "grad_dificultate": 1, "ore": 1},

        # --- CAROSERIE ---
        {"nume": "Ford - Vopsire Bara",   "skill_req": 3, "grad_dificultate": 2, "ore": 3},
        {"nume": "VW - Indreptare Aripa", "skill_req": 3, "grad_dificultate": 2, "ore": 5},  # Task MARE (Split)
        {"nume": "Porsche - Polish",      "skill_req": 3, "grad_dificultate": 3, "ore": 4},

        # --- REVIZII SIMPLE ---
        {"nume": "Skoda - Placute",       "skill_req": 0, "grad_dificultate": 1, "ore": 2},
        {"nume": "Fiat - Filtre",         "skill_req": 0, "grad_dificultate": 1, "ore": 1},
        {"nume": "Logan - Revizie",       "skill_req": 0, "grad_dificultate": 1, "ore": 2},
    ]

    # LOGICA DE SPARGERE (Split) aplicata pe date
    for t in raw_tasks:
        ore_totale = t["ore"]
        skill_req = t["skill_req"]
        dificultate = t["grad_dificultate"]

        # Daca task-ul e mare (> 4 ore), il spargem in doua
        if ore_totale > 4:
            ore_p1 = ore_totale // 2
            ore_p2 = ore_totale - ore_p1

            tasks_noi.append({
                "nume": f"{t['nume']} (P1)", "skill_req": skill_req, "grad_dificultate": dificultate, "ore": ore_p1
            })
            tasks_noi.append({
                "nume": f"{t['nume']} (P2)", "skill_req": skill_req, "grad_dificultate": dificultate, "ore": ore_p2
            })
        else:
            tasks_noi.append({
                "nume": t["nume"], "skill_req": skill_req, "grad_dificultate": dificultate, "ore": ore_totale
            })

    return mecanici_noi, tasks_noi

MECANICI, TASKS = get_date_manuale()

def afiseaza_mecanici():
    print(f"\n--- LISTA MECANICI DISPONIBILI ({len(MECANICI)}) ---")
    print(f"{'ID':<4} | {'NUME':<15} | {'NIVEL':<6} | {'COST/H':<8} | {'COMPETENTE (SKILLS)'}")
    print("-" * 80)

    for m in MECANICI:
        nume_skills = [SKILL_NAMES[s] for s in m["skill"]]
        str_skills = ", ".join(nume_skills)
        print(f"{m['id']:<4} | {m['nume']:<15} | {m['nivel']:<6} | {m['cost']:<8} | {str_skills}")
    print("-" * 80 + "\n")


# Parametri Algoritm Genetic
POP_SIZE = 100
GENERATIONS = 200
MUTATION_RATE = 0.15

# 2. COMPONENTELE ALGORITMULUI GENETIC

def init_population():
    #Aici se creaza indivizii
    return [[random.randint(0, len(MECANICI) - 1) for _ in range(len(TASKS))] for _ in range(POP_SIZE)]


def calculate_costs(individual): # Se creaza cost + penalizare
    total_cost = 0
    penalizari = 0
    ore_mecanici = {m["id"]: 0 for m in MECANICI}

    for task_idx, mec_id in enumerate(individual):
        mecanic = MECANICI[mec_id]
        task = TASKS[task_idx]
# 1. Cost Financiar Direct
        total_cost += task["ore"] * mecanic["cost"]
        ore_mecanici[mec_id] += task["ore"]

        # 2. Penalizare Hard: Competenta Tehnica
        if task["skill_req"] not in mecanic["skill"]:
            penalizari += 5000

        elif task["grad_dificultate"] > mecanic["nivel"]:
            diferenta = task["grad_dificultate"] - mecanic["nivel"]
            penalizari += diferenta * 2000

    # 4. Penalizare Soft: Depasire Capacitate
    for mid, ore in ore_mecanici.items():
        if ore > MECANICI[mid]["max_ore"]:
            penalizari += (ore - MECANICI[mid]["max_ore"]) * 1000

    return total_cost, penalizari


def fitness(individual): #Se genereaza scorul fitness
    cost, pen = calculate_costs(individual)
    return 1 / (cost + pen + 1)


def selection(population): # se alege individul cu scorul cel mai mare dintre cei 4
    sample = random.sample(population, 4)
    return max(sample, key=fitness)


def crossover(p1, p2): #se taie genele parintilor in 2 (x/y)(a/b) si se ia cate o trasatura de la fiecare parinte
    point = random.randint(1, len(TASKS) - 1)
    c1 = p1[:point] + p2[point:]
    c2 = p2[:point] + p1[point:]
    return c1, c2


def mutate(individual): # se creaza o fluctuatie a genelor pt ca genele sa nu ramana aceleasi
    if random.random() < MUTATION_RATE:
        idx = random.randint(0, len(TASKS) - 1)
        individual[idx] = random.randint(0, len(MECANICI) - 1)
    return individual

# 3. MOTORUL ALGORITMULUI (Execution Loop)

def run_genetic_algorithm():
    population = init_population()
    best_ever = None
    best_fitness_ever = -1

    for gen in range(GENERATIONS):
        new_population = []

        # Elitism - preia cea mai buna gena si o pune in generatia urmatoare
        population.sort(key=fitness, reverse=True)
        if fitness(population[0]) > best_fitness_ever:
            best_fitness_ever = fitness(population[0])
            best_ever = population[0][:]

        new_population.append(population[0])

        # Evolutie - se preiau 2 parinti cu gene bune si incercam sa creem un copil cu gene si mai bune ca parintii,dar cu posibilitatea sa iasa mai rau
        while len(new_population) < POP_SIZE:
            p1 = selection(population)
            p2 = selection(population)
            c1, c2 = crossover(p1, p2)
            new_population.append(mutate(c1))
            if len(new_population) < POP_SIZE:
                new_population.append(mutate(c2))

        population = new_population

    return best_ever

# 4. RAPORTARE REZULTATE

def run_benchmarking():
    afiseaza_mecanici()

    print("=== RULARE ALGORITM GENETIC (OPTIMIZARE RESURSE) ===")

    # 1. GA
    start_time = time.time()
    best_ga = run_genetic_algorithm()
    duration_ga = time.time() - start_time
    cost_ga, pen_ga = calculate_costs(best_ga)
    print(f"COST TOTAL MANOPERA: {cost_ga} LEI")
    print("-" * 55)

    print(f"✅ STATUS: SOLUTIE OPTIMIZATA GENERATA CU SUCCES.")
    if pen_ga > 0:
        print(f"   Nota: S-au efectuat compromisuri de nivel pentru eficienta ({pen_ga} pen).")
    else:
        print(f"   Nota: Solutie ideala (Fara compromisuri).")

    # 5. Afisare Detaliata
    ore_finale = {m["id"]: 0 for m in MECANICI}

    if len(TASKS) <= 100:
        print("\n--- REPARTIZARE DETALIATA A SARCINILOR ---")
        print(f"{'SARCINA':<35} | {'CERINTA':<12} | {'MECANIC ALOCAT':<25} | {'COST':<10} | {'STATUS'}")
        print("-" * 110)

        for i, mid in enumerate(best_ga):
            task = TASKS[i]
            mec = MECANICI[mid]

            ore_finale[mid] += task["ore"]
            cost_linie = task["ore"] * mec["cost"]

            skill_req_name = SKILL_NAMES[task["skill_req"]]
            mec_skills_names = [SKILL_NAMES[s] for s in mec["skill"]]

            # Construim textul
            sarcina_txt = f"{task['nume']} (Dif:{task['grad_dificultate']})"
            mecanic_txt = f"{mec['nume']} (Lvl:{mec['nivel']})"
            cost_txt = f"{cost_linie} LEI"

            # Validare inteligenta
            if task["skill_req"] not in mec["skill"]:
                valid = "❌ Lipsa Skill"
            elif task["grad_dificultate"] > mec["nivel"]:
                valid = "⚠️ Nivel Mic"
            else:
                valid = "✅ OK"

            print(f"{sarcina_txt:<35} | {skill_req_name:<12} | {mecanic_txt:<25} | {cost_txt:<10} | {valid}")

    # 6. Afisare Incarcare
    print("\n--- RAPORT INCARCARE MECANICI ---")
    for mid, ore in ore_finale.items():
        limita = MECANICI[mid]['max_ore']

        if ore > limita:
            status_ore = f"⚠️ ({ore - limita}h extra)"
        else:
            status_ore = ""

        if ore > 0:
            print(f"{MECANICI[mid]['nume']:<15}: {ore} ore / {limita} max  {status_ore}")


if __name__ == "__main__":
    run_benchmarking()
